<!DOCTYPE html>
<meta charset="utf-8"/>
<title>Webcase client Test</title>
<script src="jquery.js"></script>
<script src="libshine.js"></script>
<script src="libmad.js"></script>
<script src="libsamplerate.js"></script>
<script src="webcast.js"></script>
<script language="javascript" type="text/javascript">
  navigator.getUserMedia  = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

  // Configuration
  var wsUri = "ws://localhost:8080/mount";
  var file;
  var bitrate = 128;
  var bitrates = [ 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 192, 224, 256, 320 ];
  var samplerate = 44100;
  var samplerates = [ 8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000 ];
  var channels = 2;
  var samplerate;
  var encoder = Webcast.Encoder.Mp3;
  var audioContext;
  var webcast;
  var passThrough = false;
  var useAsynchronous = false;
  var useMad = false;
  var audioSource;

  function createAudioContext() {
    if (typeof webkitAudioContext !== "undefined") {
      audioContext = new webkitAudioContext();
    } else {
      audioContext = new AudioContext();
    }
    samplerate = audioContext.sampleRate;
  }

  function killWebcast() {
    if (audioSource) {
      audioSource.remove();
      audioSource = null;
    }
    if (webcast) {
      webcast.close();
      webcast = null;
    }
    if (audioContext) {
      audioContext = null;
    }
  }

  function createEncoder(inputSamplerate) {
    samplerate = parseInt($("#samplerate").val());
    bitrate = parseInt($("#bitrate").val());
    
    if ($("#stereo").is(":checked")) {
      channels = 2;
    } else {
      channels = 1;
    }

    var enc = new encoder({
      channels: channels,
      samplerate: samplerate,
      bitrate: bitrate
    });

    if (inputSamplerate !== samplerate) {
      enc = new Webcast.Encoder.Resample({
        encoder: enc,
        ratio: parseFloat(samplerate) / parseFloat(inputSamplerate)
      });
    }

    if (useAsynchronous) {
      enc = new Webcast.Encoder.Asynchronous({
        scripts: ["http://localhost:8000/libsamplerate.js", "http://localhost:8000/libshine.js", "http://localhost:8000/webcast.js"],
        encoder: enc
      });
    }

    return enc;
  }

  function createWebcastNode(source) {
    webcast = new Webcast.Node({
      uri: wsUri,
      encoder: createEncoder(audioContext.sampleRate),
      context: audioContext,
      options: {passThrough: passThrough}
    });
    
    source.connect(webcast);
    webcast.connect(audioContext.destination);
  }

  function createAudioSource() {
    killWebcast();
    createAudioContext();

    if (useMad) {
      var enc = createEncoder(audioContext.sampleRate);
      var socket = webcast = new Webcast.Socket({
        uri: wsUri,
        mime: enc.mime,
        info: enc.info
      }); 

      var format;
      var handler;
      var create = function () {
        createMadDecoder(file, function (decoder) {
          var fn = function (data, err) {
            if (!socket.isOpen()) {
              return;
            }
            if (err) {
              clearInterval(handler);
              format = handler = null;
              create();
              return;
            }
            
            data = data.slice(0,channels);
            enc.encode(data, function (encoded) {
              if (webcast) {
                webcast.sendData(encoded);
              }

              // Let's pretend format does not change accross mp3 frame,
              // Screw you crazy specs and encoders.
              if (!handler) {
                format = decoder.getCurrentFormat();
                if (format.sampleRate !== samplerate) {
                  enc = createEncoder(format.sampleRate);
                }
                var frameDuration = 1000*parseFloat(data[0].length)/format.sampleRate;

                // Now, execute this function every frameDuration.
                handler = setInterval(function () {
                  decoder.decodeFrame(fn);
                }, frameDuration);
              }
            });
          };
          decoder.decodeFrame(fn);
        });
      };
      socket.socket.addEventListener("open", function() {
        create();
      });
      return;
    }

    audioSource = new Audio();

    audioSource.src = URL.createObjectURL(file);
    audioSource.controls = true;
    audioSource.autoplay = false;
    audioSource.loop = true;

    audioSource.addEventListener("canplay", function () {
      var source = audioContext.createMediaElementSource(audioSource);
      createWebcastNode(source);
      audioSource.play();
    }, false);

    $("#player").append(audioSource);
  }

  function init() {
    $("#play-audio").click(function() {
      createAudioSource();
    });

    var el, i, v;
    for (i = 0; i<samplerates.length; i++) {
      v = samplerates[i];
      el = $("<option value='" + v + "'" + (samplerate == v ? "selected" : "") + ">" + v + "</option>");
      $("#samplerate").append(el);
    }

    for (i = 0; i<bitrates.length; i++) {
      v = bitrates[i];
      el = $("<option value='" + v + "'" + (bitrate == v ? "selected" : "") + ">" + v + "</option>");
      $("#bitrate").append(el);
    }

    $("#record-audio").click(function () {
      navigator.getUserMedia({audio:true, video:false}, function (stream) {
        killWebcast();

        createAudioContext();
        var source = audioContext.createMediaStreamSource(stream);

        createWebcastNode(source);
      }, function(e) {
        console.log("getUserMedia error: "+e.name+" "+e.message);
      });
    });

    $("#send-metadata").click(function () {
      if (webcast) {
        webcast.sendMetadata({
          title:  $("#title").val(),
          artist: $("#artist").val()
        });
      }
    });

    $("#mp3").change(function () {
      if (this.checked)
        encoder = Webcast.Encoder.Mp3;
    });

    $("#raw").change(function () {
      if (this.checked)
        encoder = Webcast.Encoder.Raw;
    });

    $("#stop").click(function () {
      killWebcast();
    });

    $("#file").change(function () {
      file = this.files[0];
    });

    $("#asynchronous").change(function () {
      useAsynchronous = this.checked;
    });

    $("#passThrough").change(function () {
      passThrough = this.checked; 
    });

    $("#mad").change(function () {
      useMad = this.checked;
      if (useMad) {
        $("#file").attr({accept: "audio/mpeg"});
        $("#passThrough").removeAttr("checked");
        passThrough = false;
      } else {
        $("#file").attr({accept: "audio/*"});
      }
    });
  }

  $(init);
</script>

<h2>Webcast Client Test</h2>
Encoder:
<input type="radio" name="encoder" value="mp3" id="mp3" checked>MP3
<input type="radio" name="encoder" value="raw"   id="raw">Raw<br>
<br>
Encoding setup:<br>
Channels:
  <input type="radio" name="channels" value="2" id="stereo" checked>Stereo
  <input type="radio" name="channels" value="1">Mono<br>
Samplerate: <select id="samplerate"></select><br>
  Bitrate:  <select id="bitrate"></select><br>
<br>
Play stream locally: <input type="checkbox" id="passThrough"><br>
Use asynchronous worker: <input type="checkbox" id="asynchronous"><br>
Decode using libmad.js: <input type="checkbox" id="mad"><br>
<br>
Stream from the microphone:<br>
<button id="record-audio">Record</button><br>
<br>
Choose a file to play:<br>
<div id="player">
  <input type="file" id="file" accept="audio/*"><br>
  <button id="play-audio">Play</button><br>
</div>
<br>
Stop Streaming:<br>
<button id="stop">Stop</button><br>
<br>
Send metadata:<br>
Artist:
<input id="artist" type="text"><br>
Title:
<input id="title" type="text"><br>
<button id="send-metadata">Send</button><br>
<div id="output"></div>
</html>
